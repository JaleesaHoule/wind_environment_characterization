{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "e8a9d3af",
   "metadata": {},
   "outputs": [],
   "source": [
    "#split speed and difference dfs so that you can find averages on different time chunks\n",
    "def split_df(df, chunk_size = 6000): #default chunks are 10 min\n",
    "    chunks = list()\n",
    "    num_chunks = len(df) // chunk_size + 1\n",
    "    for i in range(num_chunks):\n",
    "        chunks.append(df[i*chunk_size:(i+1)*chunk_size])\n",
    "    return chunks \n",
    "\n",
    "def get_fft(data,time):\n",
    "    # Number of sample points\n",
    "    N = len(time)\n",
    "    # sample spacing\n",
    "    time=np.array(time)\n",
    "    T = 1.0 /(len(time)/(time[-1]-time[0]))\n",
    "    # print(T)\n",
    "    x = np.linspace(0.0, N*T, N)\n",
    "    y = np.array(data)\n",
    "    yf = scipy.fft.fft(y)\n",
    "    xf = np.linspace(0.0, 1.0/(2.0*T), N//2)\n",
    "#     p=np.multiply(yf,time[-1])\n",
    "    X=np.log10(xf[1:])\n",
    "    Y=np.log10(2.0/N * np.abs(yf[1:(N//2)]))\n",
    "#     P=np.log10(2.0/N * np.abs(p[1:(N//2)]))\n",
    "    return(X,Y)\n",
    "\n",
    "def spectrum1(h, dt=.1):\n",
    "    \"\"\"\n",
    "    basic spectral estimation\n",
    "    Returns frequencies, power spectrum, and\n",
    "    power spectral density.\n",
    "    Only positive frequencies between (and not including)\n",
    "    zero and the Nyquist are output.\n",
    "    \"\"\"\n",
    "    nt = len(h)\n",
    "    npositive = nt//2\n",
    "    pslice = slice(1, npositive)\n",
    "    freqs = np.fft.fftfreq(nt, d=dt)[pslice] \n",
    "    ft = np.fft.fft(h)[pslice]\n",
    "    psraw = np.abs(ft) ** 2\n",
    "    # Double to account for the energy in the negative frequencies.\n",
    "    psraw *= 2\n",
    "    # Normalization for Power Spectrum\n",
    "    psraw /= nt**2\n",
    "    # Convert PS to Power Spectral Density\n",
    "    psdraw = psraw * dt * nt  # nt * dt is record length\n",
    "    return freqs, psraw, psdraw\n",
    "\n",
    "\n",
    "def avg_psd(array):\n",
    "    chunks=split_df(array)\n",
    "    N=len(chunks)-1\n",
    "    freqs=np.empty((N, 0)).tolist()\n",
    "    ps=np.empty((N, 0)).tolist()\n",
    "    psd=np.empty((N, 0)).tolist()\n",
    "    \n",
    "    for i in range (0, N):\n",
    "        freqs[i], ps[i], psd[i] =spectrum1(chunks[i], dt=.1)\n",
    "    \n",
    "    \n",
    "    arrays = [np.array(x) for x in freqs]\n",
    "    freqs_avg= [np.mean(k,dtype=np.float64) for k in zip(*arrays)] \n",
    "    arrays2 = [np.array(x) for x in psd]\n",
    "    psd_avg= [np.mean(k,dtype=np.float64) for k in zip(*arrays2)] \n",
    "    return freqs_avg,psd_avg\n",
    "    #return freqs, psd\n",
    "\n",
    "def avgdf_psd (df):\n",
    "    N=len(df.columns)\n",
    "    all_df_freq=np.empty((N, 0)).tolist()\n",
    "    all_df_psd=np.empty((N, 0)).tolist()\n",
    "    \n",
    "    for i in range (0,N):\n",
    "        all_df_freq[i], all_df_psd[i] =avg_psd(df.iloc[:,i])\n",
    "\n",
    "    arrays = [np.array(x) for x in  all_df_freq]\n",
    "    \n",
    "    \n",
    "    freqs_avg= [np.mean(k,dtype=np.float64) for k in zip(*arrays)] \n",
    "    #freqs_median= [np.median(k,dtype=np.float64) for k in zip(*arrays)] \n",
    "    \n",
    "    #freqs_avgdf=pd.DataFrame(arrays)\n",
    "    #freqs_avg=freqs_avgdf.mean()\n",
    "    arrays2 = [np.array(x) for x in all_df_psd]\n",
    "    #psd_avgdf=pd.DataFrame(arrays2)\n",
    "    #psd_avg=psd_avgdf.mean()\n",
    "    psd_avg= [np.mean(k,dtype=np.float64) for k in zip(*arrays2)] \n",
    "\n",
    "\n",
    "    #return freqs_avg,psd_avg\n",
    "    return freqs_avg, psd_avg\n",
    "\n",
    "\n",
    "#functions to deal with angle wrap around effect\n",
    "def unwrap_angle (directionarray, degrees=True):\n",
    "    if (degrees==False):\n",
    "        directionarray=+math.pi\n",
    "    else:\n",
    "        newdirection=directionarray*math.pi/180-math.pi\n",
    "    return np.unwrap(newdirection)\n",
    "\n",
    "def rewrap_angle(unwrappedarray, degrees=True):\n",
    "    rewrapped = (unwrappedarray + np.pi) % (2 * np.pi)\n",
    "    #same as np.arctan(np.cos(unwrappedarray), np.sin(unwrappedarray))\n",
    "    if degrees:\n",
    "        return rewrapped #this is in radians not degrees\n",
    "    else:\n",
    "        return rewrapped*180/math.pi\n",
    "    \n",
    "def unwrap_angulardf (directiondf, degrees=True):\n",
    "    M=len(directiondf.columns)\n",
    "    unwrappeddf=np.empty((M, 0)).tolist()\n",
    "    for i in range (0,M):\n",
    "        unwrappeddf[i]=unwrap_angle(directiondf.iloc[:,i])\n",
    "    return pd.DataFrame(unwrappeddf, index=directiondf.columns).T   "
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.15"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
